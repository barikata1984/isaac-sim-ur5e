# Inertial Parameter Identification - Implementation Log

å®Ÿè£…ã®é€²æ—ã¨æ±ºå®šäº‹é …ã‚’è¨˜éŒ²ã™ã‚‹ãƒ­ã‚°ã€‚
`implementation_plan.md` ã¨å¯¾ã«ãªã‚‹ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã€‚

---

## Phase 1: ã‚»ãƒ³ã‚µãƒ¼çµ±åˆ âœ… å®Œäº†

**å®Ÿè£…æ—¥**: 2026-02-03
**ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**: å®Œäº†
**ãƒ†ã‚¹ãƒˆ**: 36ä»¶ å…¨ãƒ‘ã‚¹

### 1.1 å®Ÿè£…ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«

```
src/sensor/
â”œâ”€â”€ __init__.py           # å…¬é–‹APIå®šç¾©
â”œâ”€â”€ data_types.py         # ãƒ‡ãƒ¼ã‚¿å‹ã‚¯ãƒ©ã‚¹
â”œâ”€â”€ data_buffer.py        # æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ç®¡ç†
â””â”€â”€ contact_sensor.py     # ã‚»ãƒ³ã‚µãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

test/
â”œâ”€â”€ conftest.py           # ãƒ†ã‚¹ãƒˆãƒ•ã‚£ã‚¯ã‚¹ãƒãƒ£
â””â”€â”€ test_sensor.py        # ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ (36ä»¶)
```

### 1.2 å®Ÿè£…å†…å®¹ã®è©³ç´°

#### 1.2.1 data_types.py

| ã‚¯ãƒ©ã‚¹ | èª¬æ˜ | ç”¨é€” |
|--------|------|------|
| `SensorData` | 1ã‚¿ã‚¤ãƒ ã‚¹ãƒ†ãƒƒãƒ—ã®æ¸¬å®šãƒ‡ãƒ¼ã‚¿ | ãƒ‡ãƒ¼ã‚¿åé›†æ™‚ã®åŸºæœ¬å˜ä½ |
| `EstimationData` | å›å¸°è¡Œåˆ—Aã¨è¦³æ¸¬ãƒ™ã‚¯ãƒˆãƒ«y | æ¨å®šã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¸ã®å…¥åŠ› |
| `EstimationResult` | æ¨å®šçµæœ + å“è³ªæŒ‡æ¨™ | æ¨å®šçµæœã®å‡ºåŠ›ãƒ»è©•ä¾¡ |
| `WrenchStamped` | ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ä»˜ãåŠ›/ãƒˆãƒ«ã‚¯ | ã‚»ãƒ³ã‚µãƒ¼å‡ºåŠ›ã®è¡¨ç¾ |

**è¨­è¨ˆæ±ºå®š**:
- `SensorData` ã¯ç”Ÿã®æ¸¬å®šå€¤ã‚’ä¿æŒã€`EstimationData` ã¸ã®å¤‰æ›ã¯ `DataBuffer` ã§å®Ÿè¡Œ
- `EstimationResult` ã«ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¨ã—ã¦ `mass`, `center_of_mass`, `inertia_matrix` ã‚’å®Ÿè£…
  - `phi` ãƒ™ã‚¯ãƒˆãƒ«ã‹ã‚‰ã®å°å‡ºã‚’è‡ªå‹•åŒ–
  - `inertia_at_com` ã§é‡å¿ƒåº§æ¨™ç³»ã¸ã®å¤‰æ›ã‚‚æä¾›

#### 1.2.2 data_buffer.py

| ãƒ¡ã‚½ãƒƒãƒ‰ | æ©Ÿèƒ½ |
|----------|------|
| `add_sample()` | ã‚µãƒ³ãƒ—ãƒ«è¿½åŠ ï¼ˆFIFOã€max_samplesåˆ¶é™ï¼‰ |
| `get_stacked_data()` | æ¨å®šç”¨ (A_stacked, y_stacked) å–å¾— |
| `compute_accelerations_from_velocities()` | æ•°å€¤å¾®åˆ†ã«ã‚ˆã‚‹åŠ é€Ÿåº¦è¨ˆç®— |
| `save_to_file()` / `load_from_file()` | JSONå½¢å¼ã§ã®æ°¸ç¶šåŒ– |
| `save_to_npz()` / `load_from_npz()` | NumPyå½¢å¼ï¼ˆå¤§è¦æ¨¡ãƒ‡ãƒ¼ã‚¿å‘ã‘ï¼‰ |
| `subsample()` | ãƒ€ã‚¦ãƒ³ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚° |
| `get_time_range()` | æ™‚é–“ç¯„å›²æŠ½å‡º |

**è¨­è¨ˆæ±ºå®š**:
- `kinematics` ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¸ã®ä¾å­˜ã¯ `get_stacked_data()` å‘¼ã³å‡ºã—æ™‚ã®ã¿
  - ãƒãƒƒãƒ•ã‚¡è‡ªä½“ã¯ kinematics ãªã—ã§å‹•ä½œå¯èƒ½
- åŠ é€Ÿåº¦è¨ˆç®—ã«ã¯ scipy ã® `uniform_filter1d` ã‚’ä½¿ç”¨ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰

#### 1.2.3 contact_sensor.py

| ã‚¯ãƒ©ã‚¹/é–¢æ•° | èª¬æ˜ |
|-------------|------|
| `WrenchSourceBase` | æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ï¼ˆåŠ›/ãƒˆãƒ«ã‚¯ã‚½ãƒ¼ã‚¹ï¼‰ |
| `IsaacSimStateCollector` | Isaac Sim ã‹ã‚‰ã®çŠ¶æ…‹å–å¾— |
| `InverseDynamicsWrenchSource` | é€†å‹•åŠ›å­¦ã«ã‚ˆã‚‹åŠ›/ãƒˆãƒ«ã‚¯è¨ˆç®— |
| `SimulatedForceSensor` | ãƒ†ã‚¹ãƒˆç”¨ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã‚»ãƒ³ã‚µãƒ¼ |
| `compute_offset_compensation_matrix()` | ã‚ªãƒ•ã‚»ãƒƒãƒˆè£œå„Ÿè¡Œåˆ—ï¼ˆè«–æ–‡ Eq.7-8ï¼‰ |
| `apply_offset_compensation()` | ã‚ªãƒ•ã‚»ãƒƒãƒˆé©ç”¨ï¼ˆè«–æ–‡ Eq.9ï¼‰ |

**è¨­è¨ˆæ±ºå®š**:

1. **åŠ›/ãƒˆãƒ«ã‚¯å–å¾—ã®æŠ½è±¡åŒ–**
   - Isaac Sim ã§ã¯ç›´æ¥çš„ãª F/T ã‚»ãƒ³ã‚µãƒ¼ãŒãªã„ãŸã‚ã€è¤‡æ•°ã®ã‚½ãƒ¼ã‚¹ã«å¯¾å¿œ
   - `WrenchSourceBase` ã‚’ç¶™æ‰¿ã™ã‚‹ã“ã¨ã§å°†æ¥ã®æ‹¡å¼µã«å¯¾å¿œ

2. **ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã‚»ãƒ³ã‚µãƒ¼ã®æä¾›**
   - `SimulatedForceSensor`: æ—¢çŸ¥ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ç†è«–çš„ãªåŠ›/ãƒˆãƒ«ã‚¯ã‚’è¨ˆç®—
   - ãƒã‚¤ã‚ºè¿½åŠ æ©Ÿèƒ½ä»˜ãï¼ˆæ¨å®šã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ãƒ†ã‚¹ãƒˆã«ä½¿ç”¨ï¼‰

3. **ã‚ªãƒ•ã‚»ãƒƒãƒˆè£œå„Ÿã®å®Ÿè£…**
   - è«–æ–‡ Eq.7-9 ã«æº–æ‹ 
   - å˜ä¸€è¡Œåˆ—ãƒ»ã‚¹ã‚¿ãƒƒã‚¯è¡Œåˆ—ã®ä¸¡æ–¹ã«å¯¾å¿œ

### 1.3 ãƒ†ã‚¹ãƒˆçµæœ

```
============================== 36 passed in 0.40s ==============================
```

| ãƒ†ã‚¹ãƒˆã‚¯ãƒ©ã‚¹ | ãƒ†ã‚¹ãƒˆæ•° | å†…å®¹ |
|--------------|----------|------|
| `TestSensorData` | 4 | ãƒ‡ãƒ¼ã‚¿å‹ã®ä½œæˆãƒ»æ¤œè¨¼ |
| `TestEstimationData` | 2 | å›å¸°è¡Œåˆ—å½¢å¼ã®æ¤œè¨¼ |
| `TestEstimationResult` | 7 | æ¨å®šçµæœãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®æ¤œè¨¼ |
| `TestWrenchStamped` | 2 | ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ä»˜ããƒ‡ãƒ¼ã‚¿ |
| `TestDataBuffer` | 12 | ãƒãƒƒãƒ•ã‚¡æ“ä½œãƒ»æ°¸ç¶šåŒ– |
| `TestOffsetCompensation` | 5 | ã‚ªãƒ•ã‚»ãƒƒãƒˆè£œå„Ÿè¨ˆç®— |
| `TestSimulatedForceSensor` | 2 | ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã‚»ãƒ³ã‚µãƒ¼ |
| `TestInverseDynamicsWrenchSource` | 2 | é€†å‹•åŠ›å­¦è¨ˆç®— |

### 1.4 Phase 1 ã® Open Questions ã¸ã®å›ç­”

| è³ªå• | å›ç­”/å¯¾å¿œ |
|------|----------|
| Isaac Sim Contact Sensor ã®ä½¿ç”¨æ–¹æ³• | ç›´æ¥ä½¿ç”¨ã¯è¤‡é›‘ãªãŸã‚ã€`InverseDynamicsWrenchSource` ã§ä»£æ›¿å¯èƒ½ãªè¨­è¨ˆã« |
| ã‚»ãƒ³ã‚µãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã¨ tool0 ã®é–¢ä¿‚ | `kinematics.compute_regressor()` ãŒ tool0 ãƒ•ãƒ¬ãƒ¼ãƒ ã§å‡ºåŠ›ã™ã‚‹ãŸã‚ã€ãã®ã¾ã¾ä½¿ç”¨ |
| ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆ | `DataBuffer` ã§ä»»æ„ã®ãƒ¬ãƒ¼ãƒˆã«å¯¾å¿œã€‚`subsample()` ã§ãƒ€ã‚¦ãƒ³ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°å¯èƒ½ |

### 1.5 Phase 2 ã¸ã®å¼•ãç¶™ãäº‹é …

1. **æ¨å®šç”¨ãƒ‡ãƒ¼ã‚¿ã®æº–å‚™**
   - `DataBuffer.get_stacked_data(kinematics)` ã§ (A, y) ã‚’å–å¾—
   - ã“ã‚Œã‚’ Phase 2 ã®æ¨å®šã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã«æ¸¡ã™

2. **ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã®ç”Ÿæˆ**
   - `SimulatedForceSensor` ã‚’ä½¿ç”¨ã—ã¦æ—¢çŸ¥ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
   - ãƒã‚¤ã‚ºãƒ¬ãƒ™ãƒ«ã‚’å¤‰ãˆã¦æ¨å®šç²¾åº¦ã‚’è©•ä¾¡å¯èƒ½

3. **ã‚ªãƒ•ã‚»ãƒƒãƒˆè£œå„Ÿ**
   - æ¨å®šå‰ã« `apply_offset_compensation()` ã‚’é©ç”¨
   - `g_init` ã¯åˆæœŸå§¿å‹¢ã§ã®é‡åŠ›ãƒ™ã‚¯ãƒˆãƒ«

### 1.6 ä½¿ç”¨ä¾‹

```python
from iparam_identification.sensor import (
    DataBuffer, SensorData, SimulatedForceSensor, EstimationResult
)
from kinematics import PinocchioKinematics

# === ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— ===
kin = PinocchioKinematics.for_ur5e()

# æ—¢çŸ¥ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰
phi_true = np.array([
    1.0,      # mass [kg]
    0.0,      # m*cx
    0.0,      # m*cy
    0.05,     # m*cz (CoM at 5cm in z)
    0.01,     # Ixx [kgÂ·mÂ²]
    0.0, 0.0, # Ixy, Ixz
    0.01,     # Iyy
    0.0,      # Iyz
    0.01,     # Izz
])

sensor = SimulatedForceSensor(kin, phi_true, noise_force_std=0.1)

# === ãƒ‡ãƒ¼ã‚¿åé›† ===
buffer = DataBuffer(max_samples=5000)

for t in range(1000):
    # è»Œé“ã‹ã‚‰ q, dq, ddq ã‚’å–å¾—ï¼ˆtrajectories ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ä½¿ç”¨ï¼‰
    q, dq, ddq = trajectory.get_value_at(t * dt)

    # åŠ›/ãƒˆãƒ«ã‚¯æ¸¬å®šï¼ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆï¼‰
    wrench = sensor.measure(q, dq, ddq, timestamp=t * dt)

    # ãƒãƒƒãƒ•ã‚¡ã«è¿½åŠ 
    buffer.add_sample(SensorData(
        timestamp=t * dt,
        q=q, dq=dq, ddq=ddq,
        force=wrench.force,
        torque=wrench.torque,
    ))

# === æ¨å®šç”¨ãƒ‡ãƒ¼ã‚¿æº–å‚™ ===
A, y = buffer.get_stacked_data(kin)
print(f"Data shape: A={A.shape}, y={y.shape}")
# Data shape: A=(6000, 10), y=(6000,)

# === ãƒ‡ãƒ¼ã‚¿ä¿å­˜ ===
buffer.save_to_npz("estimation_data.npz")

# === Phase 2 ã§ä½¿ç”¨ ===
# phi_hat = batch_total_least_squares(A, y)  # Phase 2 ã§å®Ÿè£…
# result = EstimationResult(phi=phi_hat, ...)
```

---

## Phase 2: æ¨å®šã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ  âœ… å®Œäº†

**å®Ÿè£…æ—¥**: 2026-02-04
**ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**: å®Œäº†
**ãƒ†ã‚¹ãƒˆ**: 37ä»¶ å…¨ãƒ‘ã‚¹ (sensor 36ä»¶ + estimation 37ä»¶ = 73ä»¶)

### 2.1 å®Ÿè£…ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«

```
src/estimation/
â”œâ”€â”€ __init__.py           # å…¬é–‹APIå®šç¾©
â”œâ”€â”€ base_estimator.py     # åŸºåº•ã‚¯ãƒ©ã‚¹ãƒ»ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
â”œâ”€â”€ batch_ls.py           # ãƒãƒƒãƒæœ€å°äºŒä¹—æ³•
â”œâ”€â”€ batch_tls.py          # ãƒãƒƒãƒå…¨æœ€å°äºŒä¹—æ³•
â”œâ”€â”€ rls.py                # å†å¸°æœ€å°äºŒä¹—æ³•
â”œâ”€â”€ svd_update.py         # ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ã‚¿ãƒ«SVD
â””â”€â”€ rtls.py               # å†å¸°å…¨æœ€å°äºŒä¹—æ³•

test/
â”œâ”€â”€ conftest.py           # ãƒ†ã‚¹ãƒˆãƒ•ã‚£ã‚¯ã‚¹ãƒãƒ£ï¼ˆæ›´æ–°ï¼‰
â””â”€â”€ test_estimation.py    # ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ (37ä»¶)
```

### 2.2 å®Ÿè£…å†…å®¹ã®è©³ç´°

#### 2.2.1 base_estimator.py

| ã‚¯ãƒ©ã‚¹/é–¢æ•° | èª¬æ˜ |
|-------------|------|
| `EstimatorConfig` | æ¨å®šå™¨è¨­å®šï¼ˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ•°ã€ãƒã‚¤ã‚ºå…±åˆ†æ•£ã€æ­£å‰‡åŒ–ï¼‰ |
| `BatchEstimatorBase` | ãƒãƒƒãƒæ¨å®šå™¨ã®æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ |
| `RecursiveEstimatorBase` | å†å¸°æ¨å®šå™¨ã®æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ |
| `validate_estimation_input()` | å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã®æ¤œè¨¼ |
| `compute_condition_number()` | æ¡ä»¶æ•°è¨ˆç®— |
| `compute_residual_norm()` | æ®‹å·®ãƒãƒ«ãƒ è¨ˆç®— |

#### 2.2.2 batch_ls.py - ãƒãƒƒãƒæœ€å°äºŒä¹—æ³•

| ã‚¯ãƒ©ã‚¹/é–¢æ•° | èª¬æ˜ |
|-------------|------|
| `BatchLeastSquares` | ãƒãƒƒãƒOLSæ¨å®šå™¨ã‚¯ãƒ©ã‚¹ |
| `batch_least_squares()` | OLSé–¢æ•°ï¼ˆTikhonovæ­£å‰‡åŒ–å¯¾å¿œï¼‰ |
| `weighted_least_squares()` | é‡ã¿ä»˜ãLS |
| `iteratively_reweighted_ls()` | Huberé‡ã¿ã«ã‚ˆã‚‹ãƒ­ãƒã‚¹ãƒˆæ¨å®š |

**æ•°å¼**: $\hat{\varphi} = (A^T A)^{-1} A^T y$

#### 2.2.3 batch_tls.py - ãƒãƒƒãƒå…¨æœ€å°äºŒä¹—æ³•ï¼ˆãƒ¡ã‚¤ãƒ³æ‰‹æ³•ï¼‰

| ã‚¯ãƒ©ã‚¹/é–¢æ•° | èª¬æ˜ |
|-------------|------|
| `BatchTotalLeastSquares` | ãƒãƒƒãƒTLSæ¨å®šå™¨ã‚¯ãƒ©ã‚¹ |
| `batch_total_least_squares()` | SVDã«ã‚ˆã‚‹TLSè§£è¨ˆç®— |
| `generalized_total_least_squares()` | åˆ—é‡ã¿ä»˜ãTLS |
| `row_weighted_tls()` | è¡Œé‡ã¿ä»˜ãTLS |
| `truncated_tls()` | ãƒ©ãƒ³ã‚¯å‰Šæ¸›TLS |
| `regularized_tls()` | æ­£å‰‡åŒ–TLS |

**æ•°å¼**: $y + e = (A + E)\varphi$ã€SVDåˆ†è§£ã§è§£ã‚’è¨ˆç®—

#### 2.2.4 rls.py - å†å¸°æœ€å°äºŒä¹—æ³•

| ã‚¯ãƒ©ã‚¹ | èª¬æ˜ |
|--------|------|
| `RecursiveLeastSquares` | RLSæ¨å®šå™¨ï¼ˆKalman filterå½¢å¼ï¼‰ |
| `RecursiveInstrumentalVariable` | RIVæ¨å®šå™¨ï¼ˆç›¸é–¢ãƒã‚¤ã‚ºå¯¾å¿œï¼‰ |

**ç‰¹å¾´**:
- å¿˜å´ä¿‚æ•° (forgetting factor) å¯¾å¿œ
- ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å…±åˆ†æ•£è¡Œåˆ—ã®è¿½è·¡
- ã‚ªãƒ³ãƒ©ã‚¤ãƒ³æ¨å®šã«é©ç”¨

#### 2.2.5 svd_update.py - ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ã‚¿ãƒ«SVD

| ã‚¯ãƒ©ã‚¹/é–¢æ•° | èª¬æ˜ |
|-------------|------|
| `SVDState` | SVDçŠ¶æ…‹ï¼ˆU, S, V^Tï¼‰ã®ä¿æŒ |
| `initialize_svd()` | åˆæœŸSVDè¨ˆç®— |
| `incremental_svd_update()` | 1è¡Œè¿½åŠ æ›´æ–° |
| `incremental_svd_update_block()` | è¤‡æ•°è¡Œè¿½åŠ æ›´æ–° |
| `get_tls_solution_from_svd()` | SVDã‹ã‚‰TLSè§£æŠ½å‡º |

**å‚è€ƒ**: Brand (2002) ã®ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ã‚¿ãƒ«SVDã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 

#### 2.2.6 rtls.py - å†å¸°å…¨æœ€å°äºŒä¹—æ³•ï¼ˆè«–æ–‡ã®ä¸»è¦è²¢çŒ®ï¼‰

| ã‚¯ãƒ©ã‚¹ | èª¬æ˜ |
|--------|------|
| `RecursiveTotalLeastSquares` | RTLSæ¨å®šå™¨ï¼ˆã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ã‚¿ãƒ«SVDä½¿ç”¨ï¼‰ |
| `WindowedRTLS` | ã‚¹ãƒ©ã‚¤ãƒ‡ã‚£ãƒ³ã‚°ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦RTLS |
| `AdaptiveRTLS` | é©å¿œçš„ãƒ©ãƒ³ã‚¯é¸æŠRTLS |

**ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æ¦‚è¦**:
1. åˆæœŸã‚µãƒ³ãƒ—ãƒ«ã§SVDåˆæœŸåŒ–ï¼ˆ2-3ã‚µãƒ³ãƒ—ãƒ«ï¼‰
2. æ–°ãƒ‡ãƒ¼ã‚¿ã§SVDã‚’å¢—åˆ†æ›´æ–°
3. æœ€å°ç‰¹ç•°å€¤ã«å¯¾å¿œã™ã‚‹Vã‹ã‚‰TLSè§£ã‚’æŠ½å‡º

### 2.3 ãƒ†ã‚¹ãƒˆçµæœ

```
============================== 37 passed in 0.10s ==============================
```

| ãƒ†ã‚¹ãƒˆã‚¯ãƒ©ã‚¹ | ãƒ†ã‚¹ãƒˆæ•° | å†…å®¹ |
|--------------|----------|------|
| `TestEstimatorConfig` | 3 | è¨­å®šã‚¯ãƒ©ã‚¹ã®æ¤œè¨¼ |
| `TestValidateInput` | 4 | å…¥åŠ›æ¤œè¨¼ |
| `TestConditionNumber` | 2 | æ¡ä»¶æ•°è¨ˆç®— |
| `TestBatchLeastSquares` | 4 | ãƒãƒƒãƒOLS |
| `TestIterativelyReweightedLS` | 1 | ãƒ­ãƒã‚¹ãƒˆæ¨å®š |
| `TestBatchTotalLeastSquares` | 4 | ãƒãƒƒãƒTLS |
| `TestTLSvOLS` | 1 | TLS vs OLS æ¯”è¼ƒ |
| `TestRecursiveLeastSquares` | 5 | RLS |
| `TestRecursiveTotalLeastSquares` | 4 | RTLS |
| `TestWindowedRTLS` | 2 | ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦RTLS |
| `TestSVDState` | 2 | SVDçŠ¶æ…‹ |
| `TestIncrementalSVD` | 3 | ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ã‚¿ãƒ«SVD |
| `TestEstimationIntegration` | 2 | çµ±åˆãƒ†ã‚¹ãƒˆ |

### 2.4 è¨­è¨ˆæ±ºå®š

1. **ãƒãƒƒãƒ vs å†å¸°ã®ä¸¡æ–¹ã‚’æä¾›**
   - ã‚ªãƒ•ãƒ©ã‚¤ãƒ³å‡¦ç†ã«ã¯ãƒãƒƒãƒTLSã‚’æ¨å¥¨
   - ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å‡¦ç†ã«ã¯RTLSã‚’ä½¿ç”¨

2. **TLSç”¨SVDã®åˆ‡ã‚Šè©°ã‚è¨­å®š**
   - TLSè§£æŠ½å‡ºã«ã¯æœ€å°ç‰¹ç•°å€¤ãŒå¿…è¦
   - `initialize_svd(eps=0)` ã§ãƒ•ãƒ«ãƒ©ãƒ³ã‚¯ã‚’ä¿æŒ

3. **ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ã‚¿ãƒ«SVDã®å®Ÿè£…**
   - Brand (2002) ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã«åŸºã¥ã
   - ãƒãƒƒãƒTLSã¨å®Œå…¨ä¸€è‡´ã¯ä¿è¨¼ã•ã‚Œãªã„ãŒã€å®Ÿç”¨çš„ãªç²¾åº¦ã‚’é”æˆ

### 2.5 ä½¿ç”¨ä¾‹

```python
from iparam_identification.estimation import (
    BatchTotalLeastSquares,
    RecursiveTotalLeastSquares,
    batch_total_least_squares,
)

# === ãƒãƒƒãƒæ¨å®šï¼ˆã‚ªãƒ•ãƒ©ã‚¤ãƒ³ï¼‰ ===
# DataBuffer ã‹ã‚‰å–å¾—ã—ãŸ A, y ã‚’ä½¿ç”¨
estimator = BatchTotalLeastSquares()
result = estimator.estimate(A, y)

print(result)
# EstimationResult:
#   Mass: 1.0000 kg
#   Center of Mass: [0.0000, 0.0000, 0.0500] m
#   Inertia Matrix (sensor frame): ...

# === å†å¸°æ¨å®šï¼ˆã‚ªãƒ³ãƒ©ã‚¤ãƒ³ï¼‰ ===
estimator = RecursiveTotalLeastSquares()

for A_k, y_k in measurement_stream:
    phi = estimator.update(A_k, y_k)
    print(f"Current mass: {phi[0]:.3f} kg")
```

### 2.6 Phase 3 ã¸ã®å¼•ãç¶™ãäº‹é …

1. **æ¨å®šç²¾åº¦ã®å‘ä¸Š**
   - åŠ±èµ·è»Œé“ã®æœ€é©åŒ–ã§æ¡ä»¶æ•°ã‚’æ”¹å–„
   - `compute_condition_number()` ã§äº‹å‰è©•ä¾¡å¯èƒ½

2. **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ä½¿ç”¨**
   - RTLSã¾ãŸã¯WindowedRTLSã‚’ä½¿ç”¨
   - åˆæœŸåŒ–ã«ã¯2-3ã‚µãƒ³ãƒ—ãƒ«å¿…è¦

---

## Isaac Sim çµ±åˆãƒ†ã‚¹ãƒˆ âœ… å®Œäº†

**å®Ÿè£…æ—¥**: 2026-02-04
**ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**: å®Œäº†
**ç²¾åº¦**: è³ªé‡èª¤å·® 0.01%ã€æ…£æ€§èª¤å·® < 0.1%

### 3.1 ãƒ†ã‚¹ãƒˆæ§‹æˆ

#### 3.1.1 ãƒ†ã‚¹ãƒˆç‰©ä½“ï¼ˆãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ï¼‰

| é …ç›® | å€¤ |
|------|-----|
| å½¢çŠ¶ | ç›´æ–¹ä½“ |
| å¯¸æ³• | 10cm Ã— 15cm Ã— 20cm |
| æè³ª | ã‚¢ãƒ«ãƒŸãƒ‹ã‚¦ãƒ  (2700 kg/mÂ³) |
| è³ªé‡ | 8.1 kg |
| é‡å¿ƒã‚ªãƒ•ã‚»ãƒƒãƒˆ | [0, 0, 0.1] m (tool0ã‹ã‚‰) |

#### 3.1.2 æ…£æ€§ãƒ†ãƒ³ã‚½ãƒ«ï¼ˆtool0ãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰

```
I = [0.1232, 0.0000, 0.0000]
    [0.0000, 0.1148, 0.0000]  kgÂ·mÂ²
    [0.0000, 0.0000, 0.0219]
```

### 3.2 åŠ±èµ·è»Œé“

| ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ | å€¤ |
|-----------|-----|
| ç¨®é¡ | ãƒ•ãƒ¼ãƒªã‚¨è»Œé“ |
| æŒç¶šæ™‚é–“ | 15.0 ç§’ |
| ã‚µãƒ³ãƒ—ãƒ«æ•° | 1501 |
| ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°å‘¨æ³¢æ•° | 100 Hz |
| é«˜èª¿æ³¢æ•° | 4 |
| åŸºæœ¬å‘¨æ³¢æ•° | 0.25 Hz |
| ãƒ–ãƒ¬ãƒ³ãƒ‰æ™‚é–“ | 1.0 ç§’ |

### 3.3 æ¨å®šçµæœ

#### 3.3.1 ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¤å·®

| ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ | çœŸå€¤ | OLSæ¨å®š | TLSæ¨å®š | èª¤å·®(OLS) | èª¤å·®(TLS) |
|-----------|------|---------|---------|-----------|-----------|
| m (kg) | 8.1000 | 8.1005 | 8.1009 | **0.01%** | **0.01%** |
| mÂ·cz (kgÂ·m) | 0.8100 | 0.8102 | 0.8102 | 0.02% | 0.02% |
| Ixx (kgÂ·mÂ²) | 0.1232 | 0.1232 | 0.1232 | 0.04% | 0.04% |
| Iyy (kgÂ·mÂ²) | 0.1148 | 0.1148 | 0.1148 | 0.00% | 0.01% |
| Izz (kgÂ·mÂ²) | 0.0219 | 0.0219 | 0.0219 | 0.06% | 0.05% |

#### 3.3.2 æ¨å®šå“è³ªæŒ‡æ¨™

| æŒ‡æ¨™ | å€¤ |
|------|-----|
| æ¡ä»¶æ•° Îº(A) | 4.57 |
| åé›†ã‚µãƒ³ãƒ—ãƒ«æ•° | 1491 |
| å›å¸°è¡Œåˆ—ã‚µã‚¤ã‚º | (8946, 10) |

### 3.4 è§£æ±ºã—ãŸæŠ€è¡“çš„èª²é¡Œ

#### 3.4.1 Pythonç’°å¢ƒè¡çª

**å•é¡Œ**: Isaac Sim (Python 3.11) ã¨ ROS 2 (Python 3.12) ã®ç’°å¢ƒè¡çª

**è§£æ±ºç­–**:
1. Pinocchio ã‚’ Isaac Sim ã® Python ç’°å¢ƒã«ç›´æ¥ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ« (`pin==2.7.0`)
2. `kinematics.py` ã® `load_ur_model()` ã‚’ä¿®æ­£:
   - URDFã‚­ãƒ£ãƒƒã‚·ãƒ¥æ©Ÿèƒ½ã‚’è¿½åŠ 
   - xacroå®Ÿè¡Œæ™‚ã«Isaac Simã®PYTHONPATHã‚’é™¤å¤–
3. ROSå´ã®hppfclãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’å‰Šé™¤

#### 3.4.2 xacroå®Ÿè¡Œã‚¨ãƒ©ãƒ¼

**å•é¡Œ**: Isaac Simç’°å¢ƒã§xacroå®Ÿè¡Œæ™‚ã«ã€ŒSRE module mismatchã€ã‚¨ãƒ©ãƒ¼

**è§£æ±ºç­–**:
- URDFã‚’äº‹å‰ç”Ÿæˆã—ã¦ã‚­ãƒ£ãƒƒã‚·ãƒ¥ (`/tmp/ur_urdf_cache/ur5e.urdf`)
- xacroå®Ÿè¡Œæ™‚ã«ç’°å¢ƒå¤‰æ•°ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—

#### 3.4.3 Isaac Simãƒ­ã‚°å‡ºåŠ›

**å•é¡Œ**: Isaac Simå†…ã§ã®print()å‡ºåŠ›ãŒè¡¨ç¤ºã•ã‚Œãªã„

**è§£æ±ºç­–**:
- `log()` é–¢æ•°ã‚’å®Ÿè£…ï¼ˆflush + ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›ï¼‰
- `/tmp/iparam_identification.log` ã«ãƒ­ã‚°ä¿å­˜

### 3.5 å®Ÿè£…ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«

```
scripts/
â”œâ”€â”€ run_test.sh                 # ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã‚·ã‚§ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
â””â”€â”€ run_identification_test.py  # Isaac Simçµ±åˆãƒ†ã‚¹ãƒˆ

kinematics/src/kinematics.py    # URDFã‚­ãƒ£ãƒƒã‚·ãƒ¥æ©Ÿèƒ½è¿½åŠ 
```

### 3.6 ä½¿ç”¨ä¾‹

```bash
# ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
cd /workspaces/isaac-sim-ur5e/colcon_ws
source install/setup.bash
bash src/iparam_identification/scripts/run_test.sh

# çµæœç¢ºèª
cat /tmp/iparam_identification.log
```

---

## Phase 3: è£œåŠ©æ©Ÿèƒ½ ğŸ”„ æœªå®Ÿè£…

**ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**: æœªç€æ‰‹ï¼ˆIsaac Simçµ±åˆã«ã‚ˆã‚Šå„ªå…ˆåº¦ä½ä¸‹ï¼‰

### äºˆå®šå®Ÿè£…å†…å®¹

| ãƒ•ã‚¡ã‚¤ãƒ« | å†…å®¹ | å„ªå…ˆåº¦ |
|----------|------|--------|
| `excitation_trajectory.py` | åŠ±èµ·è»Œé“è¨­è¨ˆ | ä¸­ |
| `condition_optimizer.py` | æ¡ä»¶æ•°æœ€é©åŒ– | ä½ |
| `jerk_limiter.py` | ã‚¸ãƒ£ãƒ¼ã‚¯åˆ¶é™ | ä½ |

**æ³¨**: ç¾åœ¨ã®è»Œé“ã§ã‚‚æ¡ä»¶æ•°4.57ã¨ååˆ†è‰¯å¥½ãªãŸã‚ã€æœ€é©åŒ–ã¯å¿…é ˆã§ã¯ãªã„ã€‚

---

## å¤‰æ›´å±¥æ­´

| æ—¥ä»˜ | Phase | å†…å®¹ |
|------|-------|------|
| 2026-02-03 | 1 | ã‚»ãƒ³ã‚µãƒ¼çµ±åˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®Ÿè£…å®Œäº† |
| 2026-02-04 | 2 | æ¨å®šã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®Ÿè£…å®Œäº† |
| 2026-02-04 | V | Isaac Simçµ±åˆãƒ†ã‚¹ãƒˆå®Œäº†ï¼ˆè³ªé‡èª¤å·®0.01%é”æˆï¼‰ |
| - | 3 | ï¼ˆä»»æ„ï¼‰ |
